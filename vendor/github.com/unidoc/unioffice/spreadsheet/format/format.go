//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package format provides support for parsing and evaluating
// spreadsheetml/Excel number formats.
//
// Internally spreadsheets store numbers and dates values as a text
// representation of a floating point number (e.g. 1.2345).  This number is then
// displayed in Excel or another spreadsheet viewer differently depending on the
// number fornat of the cell style applied to the cell.
//
// As an example, the same value of 1.2345 can be displayed as:
// - "1" with format "0"
// - "1.2" with format "0.0"
// - "1.23" with format "0.00"
// - "1.235" with format "0.000"
// - "123%" with format "0%"
// - "1 23/100" with fornat "0 0/100"
// - "1.23E+00" with format "0.00E+00"
// - "29:37:41s" with format `[h]:mm:ss"s"`
package format ;import (_a "bytes";_g "fmt";_cd "github.com/unidoc/unioffice";_f "io";_d "math";_ff "strconv";_gb "strings";_c "time";);const _fca int =0;const (FmtTypeLiteral FmtType =iota ;FmtTypeDigit ;FmtTypeDigitOpt ;FmtTypeComma ;FmtTypeDecimal ;FmtTypePercent ;FmtTypeDollar ;FmtTypeDigitOptThousands ;FmtTypeUnderscore ;FmtTypeDate ;FmtTypeTime ;FmtTypeFraction ;FmtTypeText ;);func _gff (_ffd []byte )[]byte {_dad :=len (_ffd );_cgg :=false ;_gcad :=false ;for _gcde :=len (_ffd )-1;_gcde >=0;_gcde --{if _ffd [_gcde ]=='0'&&!_gcad &&!_cgg {_dad =_gcde ;}else if _ffd [_gcde ]=='.'{_cgg =true ;}else {_gcad =true ;};};if _cgg &&_gcad {if _ffd [_dad -1]=='.'{_dad --;};return _ffd [0:_dad ];};return _ffd ;};

// Token is a format token in the Excel format string.
type Token struct{Type FmtType ;Literal byte ;DateTime string ;};

// AddToken adds a format token to the format.
func (_eg *Format )AddToken (t FmtType ,l []byte ){if _eg ._e {_eg ._e =false ;return ;};switch t {case FmtTypeDecimal :_eg ._fd =true ;case FmtTypeUnderscore :_eg ._e =true ;case FmtTypeText :_eg .Whole =append (_eg .Whole ,Token {Type :t });case FmtTypeDate ,FmtTypeTime :_eg .Whole =append (_eg .Whole ,Token {Type :t ,DateTime :string (l )});case FmtTypePercent :_eg ._cdf =true ;t =FmtTypeLiteral ;l =[]byte {'%'};fallthrough;case FmtTypeDigitOpt :fallthrough;case FmtTypeLiteral ,FmtTypeDigit ,FmtTypeDollar ,FmtTypeComma :if l ==nil {l =[]byte {0};};for _ ,_ec :=range l {if _eg .IsExponential {_eg .Exponent =append (_eg .Exponent ,Token {Type :t ,Literal :_ec });}else if !_eg ._fd {_eg .Whole =append (_eg .Whole ,Token {Type :t ,Literal :_ec });}else {_eg .Fractional =append (_eg .Fractional ,Token {Type :t ,Literal :_ec });};};case FmtTypeDigitOptThousands :_eg ._ceb =true ;case FmtTypeFraction :_eb :=_gb .Split (string (l ),"\u002f");if len (_eb )==2{_eg ._fg =true ;_eg ._cde ,_ =_ff .ParseInt (_eb [1],10,64);for _ ,_gc :=range _eb [1]{if _gc =='?'||_gc =='0'{_eg ._ag ++;};};};default:_cd .Log ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0070\u0068\u0020\u0074y\u0070\u0065\u0020\u0069\u006e\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0076",t );};};

// String returns the string formatted according to the type.  In format strings
// this is the fourth item, where '@' is used as a placeholder for text.
func String (v string ,f string )string {_gaf :=Parse (f );var _fe Format ;if len (_gaf )==1{_fe =_gaf [0];}else if len (_gaf )==4{_fe =_gaf [3];};_ab :=false ;for _ ,_ebd :=range _fe .Whole {if _ebd .Type ==FmtTypeText {_ab =true ;};};if !_ab {return v ;};_gcd :=_a .Buffer {};for _ ,_gg :=range _fe .Whole {switch _gg .Type {case FmtTypeLiteral :_gcd .WriteByte (_gg .Literal );case FmtTypeText :_gcd .WriteString (v );};};return _gcd .String ();};func _gea (_eea float64 )string {_fagf :=_ff .FormatFloat (_eea ,'E',-1,64);_gbb :=_ff .FormatFloat (_eea ,'E',5,64);if len (_fagf )< len (_gbb ){return _ff .FormatFloat (_eea ,'E',2,64);};return _gbb ;};

// Number is used to format a number with a format string.  If the format
// string is empty, then General number formatting is used which attempts to mimic
// Excel's general formatting.
func Number (v float64 ,f string )string {if f ==""||f =="\u0047e\u006e\u0065\u0072\u0061\u006c"||f =="\u0040"{return NumberGeneric (v );};_ecd :=Parse (f );if len (_ecd )==1{return _cdb (v ,_ecd [0],false );}else if len (_ecd )> 1&&v < 0{return _cdb (v ,_ecd [1],true );}else if len (_ecd )> 2&&v ==0{return _cdb (v ,_ecd [2],false );};return _cdb (v ,_ecd [0],false );};var _ce =[...]uint8 {0,14,26,41,53,67,81,94,118,135,146,157,172,183};func Parse (s string )[]Format {_afc :=Lexer {};_afc .Lex (_gb .NewReader (s ));_afc ._cfcf =append (_afc ._cfcf ,_afc ._fac );return _afc ._cfcf ;};

// Value formats a value as a number or string depending on  if it appears to be
// a number or string.
func Value (v string ,f string )string {if IsNumber (v ){_cec ,_ :=_ff .ParseFloat (v ,64);return Number (_cec ,f );};return String (v ,f );};func (_cg FmtType )String ()string {if _cg >=FmtType (len (_ce )-1){return _g .Sprintf ("F\u006d\u0074\u0054\u0079\u0070\u0065\u0028\u0025\u0064\u0029",_cg );};return _be [_ce [_cg ]:_ce [_cg +1]];};func _eeg (_dbe int64 ,_ddg Format )[]byte {if !_ddg .IsExponential ||len (_ddg .Exponent )==0{return nil ;};_efc :=_ff .AppendInt (nil ,_bfb (_dbe ),10);_eacb :=make ([]byte ,0,len (_efc )+2);_eacb =append (_eacb ,'E');if _dbe >=0{_eacb =append (_eacb ,'+');}else {_eacb =append (_eacb ,'-');_dbe *=-1;};_gcb :=0;_ggc :for _cbc :=len (_ddg .Exponent )-1;_cbc >=0;_cbc --{_abd :=len (_efc )-1-_gcb ;_deg :=_ddg .Exponent [_cbc ];switch _deg .Type {case FmtTypeDigit :if _abd >=0{_eacb =append (_eacb ,_efc [_abd ]);_gcb ++;}else {_eacb =append (_eacb ,'0');};case FmtTypeDigitOpt :if _abd >=0{_eacb =append (_eacb ,_efc [_abd ]);_gcb ++;}else {for _gfd :=_cbc ;_gfd >=0;_gfd --{_adb :=_ddg .Exponent [_gfd ];if _adb .Type ==FmtTypeLiteral {_eacb =append (_eacb ,_adb .Literal );};};break _ggc ;};case FmtTypeLiteral :_eacb =append (_eacb ,_deg .Literal );default:_cd .Log ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u0065\u0078p\u0020\u0025\u0076",_deg );};};if _gcb < len (_efc ){_eacb =append (_eacb ,_efc [len (_efc )-_gcb -1:_gcb -1]...);};_bd (_eacb [2:]);return _eacb ;};func _cdb (_gafb float64 ,_bf Format ,_ea bool )string {if _bf ._ad {return NumberGeneric (_gafb );};_dc :=make ([]byte ,0,20);_gf :=_d .Signbit (_gafb );_cfc :=_d .Abs (_gafb );_ge :=int64 (0);_gafe :=int64 (0);if _bf .IsExponential {for _cfc >=10{_gafe ++;_cfc /=10;};for _cfc < 1{_gafe --;_cfc *=10;};}else if _bf ._cdf {_cfc *=100;}else if _bf ._fg {if _bf ._cde ==0{_fea :=_d .Pow (10,float64 (_bf ._ag ));_fc ,_ceca :=1.0,1.0;_ =_fc ;for _eac :=1.0;_eac < _fea ;_eac ++{_ ,_ed :=_d .Modf (_cfc *float64 (_eac ));if _ed < _ceca {_ceca =_ed ;_fc =_eac ;if _ed ==0{break ;};};};_bf ._cde =int64 (_fc );};_ge =int64 (_cfc *float64 (_bf ._cde )+0.5);if len (_bf .Whole )> 0&&_ge > _bf ._cde {_ge =int64 (_cfc *float64 (_bf ._cde ))%_bf ._cde ;_cfc -=float64 (_ge )/float64 (_bf ._cde );}else {_cfc -=float64 (_ge )/float64 (_bf ._cde );if _d .Abs (_cfc )< 1{_fgd :=true ;for _ ,_cgc :=range _bf .Whole {if _cgc .Type ==FmtTypeDigitOpt {continue ;};if _cgc .Type ==FmtTypeLiteral &&_cgc .Literal ==' '{continue ;};_fgd =false ;};if _fgd {_bf .Whole =nil ;};};};};_bge :=1;for _ ,_ccd :=range _bf .Fractional {if _ccd .Type ==FmtTypeDigit ||_ccd .Type ==FmtTypeDigitOpt {_bge ++;};};_cfc +=5*_d .Pow10 (-_bge );_fdg ,_gfg :=_d .Modf (_cfc );_dc =append (_dc ,_ba (_fdg ,_gafb ,_bf )...);_dc =append (_dc ,_ebb (_gfg ,_gafb ,_bf )...);_dc =append (_dc ,_eeg (_gafe ,_bf )...);if _bf ._fg {_dc =_ff .AppendInt (_dc ,_ge ,10);_dc =append (_dc ,'/');_dc =_ff .AppendInt (_dc ,_bf ._cde ,10);};if !_ea &&_gf {return "\u002d"+string (_dc );};return string (_dc );};

// NumberGeneric formats the number with the generic format which attemps to
// mimic Excel's general formatting.
func NumberGeneric (v float64 )string {if _d .Abs (v )>=_cgf ||_d .Abs (v )<=_ga &&v !=0{return _gea (v );};_cbca :=make ([]byte ,0,15);_cbca =_ff .AppendFloat (_cbca ,v ,'f',-1,64);if len (_cbca )> 11{_feg :=_cbca [11]-'0';if _feg >=5&&_feg <=9{_cbca [10]++;_cbca =_cbca [0:11];_cbca =_fdgb (_cbca );};_cbca =_cbca [0:11];}else if len (_cbca )==11{if _cbca [len (_cbca )-1]=='9'{_cbca [len (_cbca )-1]++;_cbca =_fdgb (_cbca );};};_cbca =_gff (_cbca );return string (_cbca );};func _fdgb (_bgf []byte )[]byte {for _ggb :=len (_bgf )-1;_ggb > 0;_ggb --{if _bgf [_ggb ]=='9'+1{_bgf [_ggb ]='0';if _bgf [_ggb -1]=='.'{_ggb --;};_bgf [_ggb -1]++;};};if _bgf [0]=='9'+1{_bgf [0]='0';copy (_bgf [1:],_bgf [0:]);_bgf [0]='1';};return _bgf ;};func _ebb (_fag ,_eeb float64 ,_ca Format )[]byte {if len (_ca .Fractional )==0{return nil ;};_aec :=_ff .AppendFloat (nil ,_fag ,'f',-1,64);if len (_aec )> 2{_aec =_aec [2:];}else {_aec =nil ;};_deb :=make ([]byte ,0,len (_aec ));_deb =append (_deb ,'.');_cea :=0;_dec :for _gfc :=0;_gfc < len (_ca .Fractional );_gfc ++{_agge :=_gfc ;_eda :=_ca .Fractional [_gfc ];switch _eda .Type {case FmtTypeDigit :if _agge < len (_aec ){_deb =append (_deb ,_aec [_agge ]);_cea ++;}else {_deb =append (_deb ,'0');};case FmtTypeDigitOpt :if _agge >=0{_deb =append (_deb ,_aec [_agge ]);_cea ++;}else {break _dec ;};case FmtTypeLiteral :_deb =append (_deb ,_eda .Literal );default:_cd .Log ("\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020f\u0072\u0061\u0063\u0074\u0069\u006f\u006ea\u006c\u0020\u0025\u0076",_eda );};};return _deb ;};func _ecae (_ggd _c .Time )_c .Time {_ggd =_ggd .UTC ();return _c .Date (_ggd .Year (),_ggd .Month (),_ggd .Day (),_ggd .Hour (),_ggd .Minute (),_ggd .Second (),_ggd .Nanosecond (),_c .Local );};

// Format is a parsed number format.
type Format struct{Whole []Token ;Fractional []Token ;Exponent []Token ;IsExponential bool ;_fg bool ;_cdf bool ;_ad bool ;_ceb bool ;_e bool ;_fd bool ;_cde int64 ;_ag int ;};type Lexer struct{_fac Format ;_cfcf []Format ;};func _ba (_bde ,_gca float64 ,_eff Format )[]byte {if len (_eff .Whole )==0{return nil ;};_cgd :=_c .Date (1899,12,30,0,0,0,0,_c .UTC );_db :=_cgd .Add (_c .Duration (_gca *float64 (24*_c .Hour )));_db =_ecae (_db );_bdg :=_ff .AppendFloat (nil ,_bde ,'f',-1,64);_bc :=make ([]byte ,0,len (_bdg ));_aa :=0;_fa :=1;_gcc :for _cdee :=len (_eff .Whole )-1;_cdee >=0;_cdee --{_gae :=len (_bdg )-1-_aa ;_add :=_eff .Whole [_cdee ];switch _add .Type {case FmtTypeDigit :if _gae >=0{_bc =append (_bc ,_bdg [_gae ]);_aa ++;_fa =_cdee ;}else {_bc =append (_bc ,'0');};case FmtTypeDigitOpt :if _gae >=0{_bc =append (_bc ,_bdg [_gae ]);_aa ++;_fa =_cdee ;}else {for _de :=_cdee ;_de >=0;_de --{_baa :=_eff .Whole [_de ];if _baa .Type ==FmtTypeLiteral {_bc =append (_bc ,_baa .Literal );};};break _gcc ;};case FmtTypeDollar :for _feb :=_aa ;_feb < len (_bdg );_feb ++{_bc =append (_bc ,_bdg [len (_bdg )-1-_feb ]);_aa ++;};_bc =append (_bc ,'$');case FmtTypeComma :if !_eff ._ceb {_bc =append (_bc ,',');};case FmtTypeLiteral :_bc =append (_bc ,_add .Literal );case FmtTypeDate :_bc =append (_bc ,_bd (_ebcg (_db ,_add .DateTime ))...);case FmtTypeTime :_bc =append (_bc ,_bd (_ebdb (_db ,_gca ,_add .DateTime ))...);default:_cd .Log ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0077\u0068\u006f\u006c\u0065 \u0025\u0076",_add );};};_agg :=_bd (_bc );if _aa < len (_bdg )&&(_aa !=0||_eff ._fd ){_ffe :=len (_bdg )-_aa ;_cb :=make ([]byte ,len (_agg )+_ffe );copy (_cb ,_agg [0:_fa ]);copy (_cb [_fa :],_bdg [0:]);copy (_cb [_fa +_ffe :],_agg [_fa :]);_agg =_cb ;};if _eff ._ceb {_dde :=_a .Buffer {};_ee :=0;for _ead :=len (_agg )-1;_ead >=0;_ead --{if !(_agg [_ead ]>='0'&&_agg [_ead ]<='9'){_ee ++;}else {break ;};};for _cebg :=0;_cebg < len (_agg );_cebg ++{_fdgf :=(len (_agg )-_cebg -_ee );if _fdgf %3==0&&_fdgf !=0&&_cebg !=0{_dde .WriteByte (',');};_dde .WriteByte (_agg [_cebg ]);};_agg =_dde .Bytes ();};return _agg ;};const _gfa int =34;func _ebcg (_bff _c .Time ,_cga string )[]byte {_bfg :=[]byte {};_bgb :=0;for _cgga :=0;_cgga < len (_cga );_cgga ++{var _bdf string ;if _cga [_cgga ]=='/'{_bdf =string (_cga [_bgb :_cgga ]);_bgb =_cgga +1;}else if _cgga ==len (_cga )-1{_bdf =string (_cga [_bgb :_cgga +1]);}else {continue ;};switch _bdf {case "\u0079\u0079":_bfg =_bff .AppendFormat (_bfg ,"\u0030\u0036");case "\u0079\u0079\u0079\u0079":_bfg =_bff .AppendFormat (_bfg ,"\u0032\u0030\u0030\u0036");case "\u006d":_bfg =_bff .AppendFormat (_bfg ,"\u0031");case "\u006d\u006d":_bfg =_bff .AppendFormat (_bfg ,"\u0030\u0031");case "\u006d\u006d\u006d":_bfg =_bff .AppendFormat (_bfg ,"\u004a\u0061\u006e");case "\u006d\u006d\u006d\u006d":_bfg =_bff .AppendFormat (_bfg ,"\u004aa\u006e\u0075\u0061\u0072\u0079");case "\u006d\u006d\u006dm\u006d":switch _bff .Month (){case _c .January ,_c .July ,_c .June :_bfg =append (_bfg ,'J');case _c .February :_bfg =append (_bfg ,'M');case _c .March ,_c .May :_bfg =append (_bfg ,'M');case _c .April ,_c .August :_bfg =append (_bfg ,'A');case _c .September :_bfg =append (_bfg ,'S');case _c .October :_bfg =append (_bfg ,'O');case _c .November :_bfg =append (_bfg ,'N');case _c .December :_bfg =append (_bfg ,'D');};case "\u0064":_bfg =_bff .AppendFormat (_bfg ,"\u0032");case "\u0064\u0064":_bfg =_bff .AppendFormat (_bfg ,"\u0030\u0032");case "\u0064\u0064\u0064":_bfg =_bff .AppendFormat (_bfg ,"\u004d\u006f\u006e");case "\u0064\u0064\u0064\u0064":_bfg =_bff .AppendFormat (_bfg ,"\u004d\u006f\u006e\u0064\u0061\u0079");default:_cd .Log ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0064\u0061\u0074\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_bdf );};if _cga [_cgga ]=='/'{_bfg =append (_bfg ,'/');};};return _bfg ;};const _be ="\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u004c\u0069\u0074\u0065\u0072a\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0069\u0067\u0069\u0074\u0046\u006d\u0074\u0054y\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0043o\u006d\u006d\u0061\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0065\u0063\u0069\u006da\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065Pe\u0072\u0063e\u006e\u0074\u0046\u006d\u0074\u0054\u0079\u0070e\u0044\u006f\u006c\u006c\u0061\u0072\u0046\u006d\u0074Ty\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0054\u0068\u006f\u0075\u0073\u0061n\u0064\u0073\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0055n\u0064\u0065\u0072\u0073c\u006f\u0072\u0065\u0046\u006d\u0074T\u0079\u0070\u0065\u0044\u0061\u0074\u0065\u0046\u006d\u0074\u0054y\u0070e\u0054\u0069\u006d\u0065\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0046\u0072\u0061\u0063t\u0069\u006f\u006e\u0046\u006dt\u0054\u0079\u0070\u0065\u0054e\u0078\u0074";

// FmtType is the type of a format token.
//go:generate stringer -type=FmtType
type FmtType byte ;func _bfb (_bga int64 )int64 {if _bga < 0{return -_bga ;};return _bga ;};const _daf int =34;const _bgd int =0;const _efd int =-1;const _gbe int =34;func (_daa *Lexer )Lex (r _f .Reader ){_adda ,_bad ,_dda :=0,0,0;_bbb :=-1;_ece ,_eega ,_ccgc :=0,0,0;_ =_eega ;_ =_ccgc ;_aef :=1;_ =_aef ;_edf :=make ([]byte ,4096);_bca :=false ;for !_bca {_gge :=0;if _ece > 0{_gge =_bad -_ece ;};_bad =0;_ggg ,_bgbd :=r .Read (_edf [_gge :]);if _ggg ==0||_bgbd !=nil {_bca =true ;};_dda =_ggg +_gge ;if _dda < len (_edf ){_bbb =_dda ;};{_adda =_gbe ;_ece =0;_eega =0;_ccgc =0;};{if _bad ==_dda {goto _gcdf ;};switch _adda {case 34:goto _gga ;case 35:goto _aab ;case 0:goto _fed ;case 36:goto _cef ;case 37:goto _ccfb ;case 1:goto _dgd ;case 2:goto _gbff ;case 38:goto _bcag ;case 3:goto _bfc ;case 4:goto _ged ;case 39:goto _dca ;case 5:goto _gfe ;case 6:goto _bgg ;case 7:goto _ggea ;case 8:goto _dce ;case 40:goto _cbbf ;case 9:goto _bdc ;case 41:goto _gbg ;case 10:goto _ccdf ;case 42:goto _ega ;case 11:goto _bebg ;case 43:goto _fafd ;case 44:goto _bded ;case 45:goto _ceafe ;case 12:goto _aeb ;case 46:goto _dgf ;case 13:goto _ecc ;case 14:goto _daeb ;case 15:goto _gfec ;case 16:goto _fad ;case 47:goto _gac ;case 17:goto _gbdb ;case 48:goto _cag ;case 18:goto _aabe ;case 19:goto _ddf ;case 20:goto _fcaa ;case 49:goto _cddf ;case 50:goto _bfa ;case 21:goto _acf ;case 22:goto _debd ;case 23:goto _deac ;case 24:goto _bfd ;case 25:goto _aeda ;case 51:goto _gaca ;case 26:goto _gfdg ;case 52:goto _faca ;case 53:goto _age ;case 54:goto _bgbb ;case 55:goto _gfce ;case 56:goto _abc ;case 57:goto _gcf ;case 27:goto _gaag ;case 28:goto _gdgc ;case 29:goto _bdb ;case 30:goto _ceg ;case 31:goto _dee ;case 58:goto _fdfg ;case 32:goto _fbff ;case 59:goto _fgbb ;case 33:goto _dbg ;case 60:goto _dbbf ;case 61:goto _baacg ;case 62:goto _aedb ;};goto _dcc ;_cdeee :switch _ccgc {case 2:{_bad =(_eega )-1;_daa ._fac .AddToken (FmtTypeDigit ,nil );};case 3:{_bad =(_eega )-1;_daa ._fac .AddToken (FmtTypeDigitOpt ,nil );};case 5:{_bad =(_eega )-1;};case 8:{_bad =(_eega )-1;_daa ._fac .AddToken (FmtTypePercent ,nil );};case 13:{_bad =(_eega )-1;_daa ._fac .AddToken (FmtTypeFraction ,_edf [_ece :_eega ]);};case 14:{_bad =(_eega )-1;_daa ._fac .AddToken (FmtTypeDate ,_edf [_ece :_eega ]);};case 15:{_bad =(_eega )-1;_daa ._fac .AddToken (FmtTypeTime ,_edf [_ece :_eega ]);};case 16:{_bad =(_eega )-1;_daa ._fac .AddToken (FmtTypeTime ,_edf [_ece :_eega ]);};case 18:{_bad =(_eega )-1;};case 20:{_bad =(_eega )-1;_daa ._fac .AddToken (FmtTypeLiteral ,_edf [_ece :_eega ]);};case 21:{_bad =(_eega )-1;_daa ._fac .AddToken (FmtTypeLiteral ,_edf [_ece +1:_eega -1]);};};goto _dcdf ;_gab :_bad =(_eega )-1;{_daa ._fac .AddToken (FmtTypeFraction ,_edf [_ece :_eega ]);};goto _dcdf ;_eee :_bad =(_eega )-1;{_daa ._fac .AddToken (FmtTypeDigitOpt ,nil );};goto _dcdf ;_gdb :_eega =_bad +1;{_daa ._fac .AddToken (FmtTypeDigitOptThousands ,nil );};goto _dcdf ;_abe :_bad =(_eega )-1;{_daa ._fac .AddToken (FmtTypePercent ,nil );};goto _dcdf ;_ggee :_bad =(_eega )-1;{_daa ._fac .AddToken (FmtTypeDate ,_edf [_ece :_eega ]);};goto _dcdf ;_gdae :_bad =(_eega )-1;{_daa ._fac .AddToken (FmtTypeDigit ,nil );};goto _dcdf ;_eab :_bad =(_eega )-1;{_daa ._fac .AddToken (FmtTypeTime ,_edf [_ece :_eega ]);};goto _dcdf ;_bef :_bad =(_eega )-1;{_daa ._fac .AddToken (FmtTypeLiteral ,_edf [_ece :_eega ]);};goto _dcdf ;_cddb :_eega =_bad +1;{_daa ._fac ._ad =true ;};goto _dcdf ;_faf :_eega =_bad +1;{_daa ._fac .AddToken (FmtTypeLiteral ,_edf [_ece :_eega ]);};goto _dcdf ;_dbd :_eega =_bad +1;{_daa ._fac .AddToken (FmtTypeDollar ,nil );};goto _dcdf ;_dcd :_eega =_bad +1;{_daa ._fac .AddToken (FmtTypeComma ,nil );};goto _dcdf ;_aed :_eega =_bad +1;{_daa ._fac .AddToken (FmtTypeDecimal ,nil );};goto _dcdf ;_fda :_eega =_bad +1;{_daa .nextFmt ();};goto _dcdf ;_cfg :_eega =_bad +1;{_daa ._fac .AddToken (FmtTypeText ,nil );};goto _dcdf ;_eef :_eega =_bad +1;{_daa ._fac .AddToken (FmtTypeUnderscore ,nil );};goto _dcdf ;_gad :_eega =_bad ;_bad --;{_daa ._fac .AddToken (FmtTypeLiteral ,_edf [_ece :_eega ]);};goto _dcdf ;_cbd :_eega =_bad ;_bad --;{_daa ._fac .AddToken (FmtTypeLiteral ,_edf [_ece +1:_eega -1]);};goto _dcdf ;_dga :_eega =_bad ;_bad --;{_daa ._fac .AddToken (FmtTypeDigitOpt ,nil );};goto _dcdf ;_ggf :_eega =_bad ;_bad --;{_daa ._fac .AddToken (FmtTypeFraction ,_edf [_ece :_eega ]);};goto _dcdf ;_bae :_eega =_bad ;_bad --;{_daa ._fac .AddToken (FmtTypePercent ,nil );};goto _dcdf ;_ccf :_eega =_bad ;_bad --;{_daa ._fac .AddToken (FmtTypeDate ,_edf [_ece :_eega ]);};goto _dcdf ;_dafc :_eega =_bad ;_bad --;{_daa ._fac .AddToken (FmtTypeDigit ,nil );};goto _dcdf ;_baac :_eega =_bad ;_bad --;{_daa ._fac .AddToken (FmtTypeTime ,_edf [_ece :_eega ]);};goto _dcdf ;_dea :_eega =_bad ;_bad --;{};goto _dcdf ;_ceaf :_eega =_bad +1;{_daa ._fac .IsExponential =true ;};goto _dcdf ;_dcb :_eega =_bad +1;{_daa ._fac .AddToken (FmtTypeLiteral ,_edf [_ece +1:_eega ]);};goto _dcdf ;_dcdf :_ece =0;if _bad ++;_bad ==_dda {goto _gcade ;};_gga :_ece =_bad ;switch _edf [_bad ]{case 34:goto _bfeg ;case 35:goto _beba ;case 36:goto _dbd ;case 37:goto _gde ;case 44:goto _dcd ;case 46:goto _aed ;case 47:goto _cbe ;case 48:goto _fcf ;case 58:goto _fba ;case 59:goto _fda ;case 63:goto _ggfa ;case 64:goto _cfg ;case 65:goto _bed ;case 69:goto _geb ;case 71:goto _efff ;case 91:goto _ccff ;case 92:goto _gfde ;case 95:goto _eef ;case 100:goto _cbe ;case 104:goto _fba ;case 109:goto _dbf ;case 115:goto _ceaa ;case 121:goto _ada ;};if 49<=_edf [_bad ]&&_edf [_bad ]<=57{goto _aefc ;};goto _faf ;_bfeg :_eega =_bad +1;_ccgc =20;goto _dfg ;_dfg :if _bad ++;_bad ==_dda {goto _ccga ;};_aab :if _edf [_bad ]==34{goto _cfb ;};goto _fbca ;_fbca :if _bad ++;_bad ==_dda {goto _bgec ;};_fed :if _edf [_bad ]==34{goto _cfb ;};goto _fbca ;_cfb :_eega =_bad +1;_ccgc =21;goto _ddgc ;_ddgc :if _bad ++;_bad ==_dda {goto _ebfg ;};_cef :if _edf [_bad ]==34{goto _fbca ;};goto _cbd ;_beba :_eega =_bad +1;_ccgc =3;goto _cece ;_cece :if _bad ++;_bad ==_dda {goto _efaa ;};_ccfb :switch _edf [_bad ]{case 35:goto _acg ;case 37:goto _acg ;case 44:goto _abf ;case 47:goto _afg ;case 48:goto _acg ;case 63:goto _acg ;};goto _dga ;_acg :if _bad ++;_bad ==_dda {goto _afef ;};_dgd :switch _edf [_bad ]{case 35:goto _acg ;case 37:goto _acg ;case 47:goto _afg ;case 48:goto _acg ;case 63:goto _acg ;};goto _cdeee ;_afg :if _bad ++;_bad ==_dda {goto _fadg ;};_gbff :switch _edf [_bad ]{case 35:goto _eabf ;case 37:goto _fgb ;case 48:goto _fde ;case 63:goto _eabf ;};if 49<=_edf [_bad ]&&_edf [_bad ]<=57{goto _dff ;};goto _cdeee ;_eabf :_eega =_bad +1;goto _ddb ;_ddb :if _bad ++;_bad ==_dda {goto _gdad ;};_bcag :switch _edf [_bad ]{case 35:goto _eabf ;case 37:goto _eabf ;case 44:goto _eabf ;case 46:goto _eabf ;case 48:goto _eabf ;case 63:goto _eabf ;case 65:goto _daea ;};goto _ggf ;_daea :if _bad ++;_bad ==_dda {goto _fgcg ;};_bfc :switch _edf [_bad ]{case 47:goto _efa ;case 77:goto _dbda ;};goto _gab ;_efa :if _bad ++;_bad ==_dda {goto _bdce ;};_ged :if _edf [_bad ]==80{goto _ebg ;};goto _gab ;_ebg :_eega =_bad +1;goto _aag ;_aag :if _bad ++;_bad ==_dda {goto _gcfg ;};_dca :if _edf [_bad ]==65{goto _daea ;};goto _ggf ;_dbda :if _bad ++;_bad ==_dda {goto _deff ;};_gfe :if _edf [_bad ]==47{goto _ceab ;};goto _gab ;_ceab :if _bad ++;_bad ==_dda {goto _gfcd ;};_bgg :if _edf [_bad ]==80{goto _cbb ;};goto _gab ;_cbb :if _bad ++;_bad ==_dda {goto _badb ;};_ggea :if _edf [_bad ]==77{goto _ebg ;};goto _gab ;_fgb :if _bad ++;_bad ==_dda {goto _debc ;};_dce :switch _edf [_bad ]{case 35:goto _ecfd ;case 37:goto _fgg ;case 63:goto _ecfd ;};if 48<=_edf [_bad ]&&_edf [_bad ]<=57{goto _ggaf ;};goto _cdeee ;_ecfd :_eega =_bad +1;goto _baf ;_baf :if _bad ++;_bad ==_dda {goto _defb ;};_cbbf :switch _edf [_bad ]{case 35:goto _eabf ;case 37:goto _eegd ;case 44:goto _eabf ;case 46:goto _eabf ;case 48:goto _eabf ;case 63:goto _eabf ;case 65:goto _daea ;};goto _ggf ;_eegd :if _bad ++;_bad ==_dda {goto _cdbc ;};_bdc :switch _edf [_bad ]{case 35:goto _cdfb ;case 44:goto _cdfb ;case 46:goto _cdfb ;case 48:goto _cdfb ;case 63:goto _cdfb ;};goto _gab ;_cdfb :_eega =_bad +1;goto _gag ;_gag :if _bad ++;_bad ==_dda {goto _eaa ;};_gbg :switch _edf [_bad ]{case 35:goto _cdfb ;case 44:goto _cdfb ;case 46:goto _cdfb ;case 48:goto _cdfb ;case 63:goto _cdfb ;case 65:goto _daea ;};goto _ggf ;_fgg :if _bad ++;_bad ==_dda {goto _fbe ;};_ccdf :if _edf [_bad ]==37{goto _fgg ;};if 48<=_edf [_bad ]&&_edf [_bad ]<=57{goto _ggaf ;};goto _cdeee ;_ggaf :_eega =_bad +1;_ccgc =13;goto _cce ;_cce :if _bad ++;_bad ==_dda {goto _ffdb ;};_ega :switch _edf [_bad ]{case 35:goto _eabf ;case 37:goto _efdf ;case 44:goto _eabf ;case 46:goto _eabf ;case 48:goto _aea ;case 63:goto _eabf ;case 65:goto _daea ;};if 49<=_edf [_bad ]&&_edf [_bad ]<=57{goto _ggaf ;};goto _ggf ;_efdf :if _bad ++;_bad ==_dda {goto _eba ;};_bebg :switch _edf [_bad ]{case 35:goto _cdfb ;case 37:goto _fgg ;case 44:goto _cdfb ;case 46:goto _cdfb ;case 63:goto _cdfb ;};if 48<=_edf [_bad ]&&_edf [_bad ]<=57{goto _ggaf ;};goto _gab ;_aea :_eega =_bad +1;goto _def ;_def :if _bad ++;_bad ==_dda {goto _baae ;};_fafd :switch _edf [_bad ]{case 35:goto _eabf ;case 37:goto _aea ;case 44:goto _eabf ;case 46:goto _eabf ;case 48:goto _aea ;case 63:goto _eabf ;case 65:goto _daea ;};if 49<=_edf [_bad ]&&_edf [_bad ]<=57{goto _ggaf ;};goto _ggf ;_fde :_eega =_bad +1;goto _gabg ;_gabg :if _bad ++;_bad ==_dda {goto _dag ;};_bded :switch _edf [_bad ]{case 35:goto _eabf ;case 37:goto _aea ;case 44:goto _eabf ;case 46:goto _eabf ;case 48:goto _fde ;case 63:goto _eabf ;case 65:goto _daea ;};if 49<=_edf [_bad ]&&_edf [_bad ]<=57{goto _dff ;};goto _ggf ;_dff :_eega =_bad +1;goto _gcgd ;_gcgd :if _bad ++;_bad ==_dda {goto _ddfb ;};_ceafe :switch _edf [_bad ]{case 35:goto _eabf ;case 37:goto _ggaf ;case 44:goto _eabf ;case 46:goto _eabf ;case 48:goto _fde ;case 63:goto _eabf ;case 65:goto _daea ;};if 49<=_edf [_bad ]&&_edf [_bad ]<=57{goto _dff ;};goto _ggf ;_abf :if _bad ++;_bad ==_dda {goto _eed ;};_aeb :if _edf [_bad ]==35{goto _gdb ;};goto _eee ;_gde :_eega =_bad +1;_ccgc =8;goto _dfe ;_dfe :if _bad ++;_bad ==_dda {goto _eebc ;};_dgf :switch _edf [_bad ]{case 35:goto _afe ;case 37:goto _cefa ;case 48:goto _cge ;case 63:goto _afe ;};if 49<=_edf [_bad ]&&_edf [_bad ]<=57{goto _cebga ;};goto _bae ;_afe :if _bad ++;_bad ==_dda {goto _bggg ;};_ecc :switch _edf [_bad ]{case 35:goto _afe ;case 47:goto _afg ;case 48:goto _afe ;case 63:goto _afe ;};goto _abe ;_cefa :if _bad ++;_bad ==_dda {goto _bcf ;};_daeb :if _edf [_bad ]==37{goto _cefa ;};if 48<=_edf [_bad ]&&_edf [_bad ]<=57{goto _cebga ;};goto _cdeee ;_cebga :if _bad ++;_bad ==_dda {goto _bdd ;};_gfec :switch _edf [_bad ]{case 37:goto _cefa ;case 47:goto _afg ;};if 48<=_edf [_bad ]&&_edf [_bad ]<=57{goto _cebga ;};goto _cdeee ;_cge :if _bad ++;_bad ==_dda {goto _cdde ;};_fad :switch _edf [_bad ]{case 35:goto _afe ;case 37:goto _cefa ;case 47:goto _afg ;case 48:goto _cge ;case 63:goto _afe ;};if 49<=_edf [_bad ]&&_edf [_bad ]<=57{goto _cebga ;};goto _abe ;_cbe :_eega =_bad +1;goto _gdef ;_gdef :if _bad ++;_bad ==_dda {goto _egc ;};_gac :switch _edf [_bad ]{case 47:goto _cbe ;case 100:goto _cbe ;case 109:goto _cbe ;case 121:goto _dgdd ;};goto _ccf ;_dgdd :if _bad ++;_bad ==_dda {goto _gagf ;};_gbdb :if _edf [_bad ]==121{goto _cbe ;};goto _ggee ;_fcf :_eega =_bad +1;_ccgc =2;goto _bee ;_bee :if _bad ++;_bad ==_dda {goto _fdd ;};_cag :switch _edf [_bad ]{case 35:goto _acg ;case 37:goto _aeba ;case 47:goto _afg ;case 48:goto _ffdc ;case 63:goto _acg ;};if 49<=_edf [_bad ]&&_edf [_bad ]<=57{goto _fec ;};goto _dafc ;_aeba :if _bad ++;_bad ==_dda {goto _bfff ;};_aabe :switch _edf [_bad ]{case 35:goto _acg ;case 37:goto _aeba ;case 47:goto _afg ;case 48:goto _aeba ;case 63:goto _acg ;};if 49<=_edf [_bad ]&&_edf [_bad ]<=57{goto _cebga ;};goto _gdae ;_ffdc :if _bad ++;_bad ==_dda {goto _aedc ;};_ddf :switch _edf [_bad ]{case 35:goto _acg ;case 37:goto _aeba ;case 47:goto _afg ;case 48:goto _ffdc ;case 63:goto _acg ;};if 49<=_edf [_bad ]&&_edf [_bad ]<=57{goto _fec ;};goto _gdae ;_fec :if _bad ++;_bad ==_dda {goto _fbd ;};_fcaa :switch _edf [_bad ]{case 37:goto _cebga ;case 47:goto _afg ;};if 48<=_edf [_bad ]&&_edf [_bad ]<=57{goto _fec ;};goto _cdeee ;_aefc :_eega =_bad +1;_ccgc =20;goto _deab ;_deab :if _bad ++;_bad ==_dda {goto _efeg ;};_cddf :switch _edf [_bad ]{case 37:goto _cebga ;case 47:goto _afg ;};if 48<=_edf [_bad ]&&_edf [_bad ]<=57{goto _fec ;};goto _gad ;_fba :_eega =_bad +1;_ccgc =15;goto _gaa ;_gaa :if _bad ++;_bad ==_dda {goto _dbee ;};_bfa :switch _edf [_bad ]{case 58:goto _fba ;case 65:goto _ecfb ;case 104:goto _fba ;case 109:goto _fba ;case 115:goto _ceaa ;};goto _baac ;_ecfb :if _bad ++;_bad ==_dda {goto _dbde ;};_acf :switch _edf [_bad ]{case 47:goto _fdf ;case 77:goto _abdg ;};goto _cdeee ;_fdf :if _bad ++;_bad ==_dda {goto _afge ;};_debd :if _edf [_bad ]==80{goto _fba ;};goto _cdeee ;_abdg :if _bad ++;_bad ==_dda {goto _faa ;};_deac :if _edf [_bad ]==47{goto _degf ;};goto _cdeee ;_degf :if _bad ++;_bad ==_dda {goto _cddg ;};_bfd :if _edf [_bad ]==80{goto _ddfe ;};goto _cdeee ;_ddfe :if _bad ++;_bad ==_dda {goto _fcg ;};_aeda :if _edf [_bad ]==77{goto _fba ;};goto _cdeee ;_ceaa :_eega =_bad +1;_ccgc =15;goto _fga ;_fga :if _bad ++;_bad ==_dda {goto _gebe ;};_gaca :switch _edf [_bad ]{case 46:goto _fce ;case 58:goto _fba ;case 65:goto _ecfb ;case 104:goto _fba ;case 109:goto _fba ;case 115:goto _ceaa ;};goto _baac ;_fce :if _bad ++;_bad ==_dda {goto _ddab ;};_gfdg :if _edf [_bad ]==48{goto _ccgce ;};goto _eab ;_ccgce :_eega =_bad +1;_ccgc =15;goto _dfd ;_dfd :if _bad ++;_bad ==_dda {goto _fgba ;};_faca :switch _edf [_bad ]{case 48:goto _gdg ;case 58:goto _fba ;case 65:goto _ecfb ;case 104:goto _fba ;case 109:goto _fba ;case 115:goto _ceaa ;};goto _baac ;_gdg :_eega =_bad +1;_ccgc =15;goto _beg ;_beg :if _bad ++;_bad ==_dda {goto _fceb ;};_age :switch _edf [_bad ]{case 48:goto _fba ;case 58:goto _fba ;case 65:goto _ecfb ;case 104:goto _fba ;case 109:goto _fba ;case 115:goto _ceaa ;};goto _baac ;_ggfa :_eega =_bad +1;_ccgc =5;goto _eacbd ;_eacbd :if _bad ++;_bad ==_dda {goto _ffa ;};_bgbb :switch _edf [_bad ]{case 35:goto _acg ;case 37:goto _acg ;case 47:goto _afg ;case 48:goto _acg ;case 63:goto _acg ;};goto _dea ;_bed :_eega =_bad +1;_ccgc =20;goto _caae ;_caae :if _bad ++;_bad ==_dda {goto _bfga ;};_gfce :switch _edf [_bad ]{case 47:goto _fdf ;case 77:goto _abdg ;};goto _gad ;_geb :if _bad ++;_bad ==_dda {goto _fcff ;};_abc :switch _edf [_bad ]{case 43:goto _ceaf ;case 45:goto _ceaf ;};goto _gad ;_efff :_eega =_bad +1;goto _fab ;_fab :if _bad ++;_bad ==_dda {goto _cfa ;};_gcf :if _edf [_bad ]==101{goto _cagg ;};goto _gad ;_cagg :if _bad ++;_bad ==_dda {goto _bfbb ;};_gaag :if _edf [_bad ]==110{goto _ffee ;};goto _bef ;_ffee :if _bad ++;_bad ==_dda {goto _becg ;};_gdgc :if _edf [_bad ]==101{goto _fecb ;};goto _bef ;_fecb :if _bad ++;_bad ==_dda {goto _ffea ;};_bdb :if _edf [_bad ]==114{goto _fdag ;};goto _bef ;_fdag :if _bad ++;_bad ==_dda {goto _ffac ;};_ceg :if _edf [_bad ]==97{goto _bdeg ;};goto _bef ;_bdeg :if _bad ++;_bad ==_dda {goto _gfca ;};_dee :if _edf [_bad ]==108{goto _cddb ;};goto _bef ;_ccff :_eega =_bad +1;_ccgc =20;goto _fbf ;_fbf :if _bad ++;_bad ==_dda {goto _dcef ;};_fdfg :switch _edf [_bad ]{case 104:goto _edb ;case 109:goto _edb ;case 115:goto _edb ;};goto _bfgg ;_bfgg :if _bad ++;_bad ==_dda {goto _fadb ;};_fbff :if _edf [_bad ]==93{goto _ffdee ;};goto _bfgg ;_ffdee :_eega =_bad +1;_ccgc =18;goto _adc ;_cdeg :_eega =_bad +1;_ccgc =16;goto _adc ;_adc :if _bad ++;_bad ==_dda {goto _fced ;};_fgbb :if _edf [_bad ]==93{goto _ffdee ;};goto _bfgg ;_edb :if _bad ++;_bad ==_dda {goto _fdab ;};_dbg :if _edf [_bad ]==93{goto _cdeg ;};goto _bfgg ;_gfde :if _bad ++;_bad ==_dda {goto _gec ;};_dbbf :goto _dcb ;_dbf :_eega =_bad +1;_ccgc =14;goto _bea ;_bea :if _bad ++;_bad ==_dda {goto _dege ;};_baacg :switch _edf [_bad ]{case 47:goto _cbe ;case 58:goto _fba ;case 65:goto _ecfb ;case 100:goto _cbe ;case 104:goto _fba ;case 109:goto _dbf ;case 115:goto _ceaa ;case 121:goto _dgdd ;};goto _ccf ;_ada :if _bad ++;_bad ==_dda {goto _dbgg ;};_aedb :if _edf [_bad ]==121{goto _cbe ;};goto _gad ;_dcc :_gcade :_adda =34;goto _gcdf ;_ccga :_adda =35;goto _gcdf ;_bgec :_adda =0;goto _gcdf ;_ebfg :_adda =36;goto _gcdf ;_efaa :_adda =37;goto _gcdf ;_afef :_adda =1;goto _gcdf ;_fadg :_adda =2;goto _gcdf ;_gdad :_adda =38;goto _gcdf ;_fgcg :_adda =3;goto _gcdf ;_bdce :_adda =4;goto _gcdf ;_gcfg :_adda =39;goto _gcdf ;_deff :_adda =5;goto _gcdf ;_gfcd :_adda =6;goto _gcdf ;_badb :_adda =7;goto _gcdf ;_debc :_adda =8;goto _gcdf ;_defb :_adda =40;goto _gcdf ;_cdbc :_adda =9;goto _gcdf ;_eaa :_adda =41;goto _gcdf ;_fbe :_adda =10;goto _gcdf ;_ffdb :_adda =42;goto _gcdf ;_eba :_adda =11;goto _gcdf ;_baae :_adda =43;goto _gcdf ;_dag :_adda =44;goto _gcdf ;_ddfb :_adda =45;goto _gcdf ;_eed :_adda =12;goto _gcdf ;_eebc :_adda =46;goto _gcdf ;_bggg :_adda =13;goto _gcdf ;_bcf :_adda =14;goto _gcdf ;_bdd :_adda =15;goto _gcdf ;_cdde :_adda =16;goto _gcdf ;_egc :_adda =47;goto _gcdf ;_gagf :_adda =17;goto _gcdf ;_fdd :_adda =48;goto _gcdf ;_bfff :_adda =18;goto _gcdf ;_aedc :_adda =19;goto _gcdf ;_fbd :_adda =20;goto _gcdf ;_efeg :_adda =49;goto _gcdf ;_dbee :_adda =50;goto _gcdf ;_dbde :_adda =21;goto _gcdf ;_afge :_adda =22;goto _gcdf ;_faa :_adda =23;goto _gcdf ;_cddg :_adda =24;goto _gcdf ;_fcg :_adda =25;goto _gcdf ;_gebe :_adda =51;goto _gcdf ;_ddab :_adda =26;goto _gcdf ;_fgba :_adda =52;goto _gcdf ;_fceb :_adda =53;goto _gcdf ;_ffa :_adda =54;goto _gcdf ;_bfga :_adda =55;goto _gcdf ;_fcff :_adda =56;goto _gcdf ;_cfa :_adda =57;goto _gcdf ;_bfbb :_adda =27;goto _gcdf ;_becg :_adda =28;goto _gcdf ;_ffea :_adda =29;goto _gcdf ;_ffac :_adda =30;goto _gcdf ;_gfca :_adda =31;goto _gcdf ;_dcef :_adda =58;goto _gcdf ;_fadb :_adda =32;goto _gcdf ;_fced :_adda =59;goto _gcdf ;_fdab :_adda =33;goto _gcdf ;_gec :_adda =60;goto _gcdf ;_dege :_adda =61;goto _gcdf ;_dbgg :_adda =62;goto _gcdf ;_gcdf :{};if _bad ==_bbb {switch _adda {case 35:goto _gad ;case 0:goto _cdeee ;case 36:goto _cbd ;case 37:goto _dga ;case 1:goto _cdeee ;case 2:goto _cdeee ;case 38:goto _ggf ;case 3:goto _gab ;case 4:goto _gab ;case 39:goto _ggf ;case 5:goto _gab ;case 6:goto _gab ;case 7:goto _gab ;case 8:goto _cdeee ;case 40:goto _ggf ;case 9:goto _gab ;case 41:goto _ggf ;case 10:goto _cdeee ;case 42:goto _ggf ;case 11:goto _gab ;case 43:goto _ggf ;case 44:goto _ggf ;case 45:goto _ggf ;case 12:goto _eee ;case 46:goto _bae ;case 13:goto _abe ;case 14:goto _cdeee ;case 15:goto _cdeee ;case 16:goto _abe ;case 47:goto _ccf ;case 17:goto _ggee ;case 48:goto _dafc ;case 18:goto _gdae ;case 19:goto _gdae ;case 20:goto _cdeee ;case 49:goto _gad ;case 50:goto _baac ;case 21:goto _cdeee ;case 22:goto _cdeee ;case 23:goto _cdeee ;case 24:goto _cdeee ;case 25:goto _cdeee ;case 51:goto _baac ;case 26:goto _eab ;case 52:goto _baac ;case 53:goto _baac ;case 54:goto _dea ;case 55:goto _gad ;case 56:goto _gad ;case 57:goto _gad ;case 27:goto _bef ;case 28:goto _bef ;case 29:goto _bef ;case 30:goto _bef ;case 31:goto _bef ;case 58:goto _gad ;case 32:goto _cdeee ;case 59:goto _cdeee ;case 33:goto _bef ;case 60:goto _gad ;case 61:goto _ccf ;case 62:goto _gad ;};};};if _ece > 0{copy (_edf [0:],_edf [_ece :]);};};_ =_bbb ;if _adda ==_efd {_cd .Log ("\u0066o\u0072m\u0061\u0074\u0020\u0070\u0061r\u0073\u0065 \u0065\u0072\u0072\u006f\u0072");};};const _cgf =1e11;const _bgfe int =0;func (_df *Lexer )nextFmt (){_df ._cfcf =append (_df ._cfcf ,_df ._fac );_df ._fac =Format {}};const _ga =1e-10;func IsNumber (data string )(_eebg bool ){_gbf ,_efe ,_bfe :=0,0,len (data );_ffde :=len (data );_fagb ,_ebbe ,_caa :=0,0,0;_ =_ebbe ;_ =_caa ;_ =_fagb ;{_gbf =_bgd ;_fagb =0;_ebbe =0;_caa =0;};{if _efe ==_bfe {goto _ffc ;};switch _gbf {case 0:goto _bgfg ;case 1:goto _dg ;case 2:goto _eca ;case 3:goto _gcdd ;case 4:goto _ede ;case 5:goto _bcg ;case 6:goto _gaed ;case 7:goto _dbb ;};goto _beb ;_ced :_ebbe =_efe ;_efe --;{_eebg =false ;};goto _gbd ;_gegg :_ebbe =_efe ;_efe --;{_eebg =_ebbe ==len (data );};goto _gbd ;_dade :_ebbe =_efe ;_efe --;{_eebg =_ebbe ==len (data );};goto _gbd ;_fgc :switch _caa {case 2:{_efe =(_ebbe )-1;_eebg =_ebbe ==len (data );};case 3:{_efe =(_ebbe )-1;_eebg =false ;};};goto _gbd ;_gbd :_fagb =0;if _efe ++;_efe ==_bfe {goto _gcg ;};_bgfg :_fagb =_efe ;switch data [_efe ]{case 43:goto _egg ;case 45:goto _egg ;};if 48<=data [_efe ]&&data [_efe ]<=57{goto _abb ;};goto _ded ;_ded :if _efe ++;_efe ==_bfe {goto _ggcb ;};_dg :goto _ded ;_egg :if _efe ++;_efe ==_bfe {goto _gda ;};_eca :if 48<=data [_efe ]&&data [_efe ]<=57{goto _abb ;};goto _ded ;_abb :if _efe ++;_efe ==_bfe {goto _abbf ;};_gcdd :if data [_efe ]==46{goto _dba ;};if 48<=data [_efe ]&&data [_efe ]<=57{goto _abb ;};goto _ded ;_dba :if _efe ++;_efe ==_bfe {goto _cab ;};_ede :if 48<=data [_efe ]&&data [_efe ]<=57{goto _ade ;};goto _ded ;_ade :if _efe ++;_efe ==_bfe {goto _cdfa ;};_bcg :if data [_efe ]==69{goto _gd ;};if 48<=data [_efe ]&&data [_efe ]<=57{goto _ade ;};goto _ded ;_gd :if _efe ++;_efe ==_bfe {goto _aaf ;};_gaed :switch data [_efe ]{case 43:goto _ecf ;case 45:goto _ecf ;};goto _ded ;_ecf :_ebbe =_efe +1;_caa =3;goto _af ;_ac :_ebbe =_efe +1;_caa =2;goto _af ;_af :if _efe ++;_efe ==_bfe {goto _bfba ;};_dbb :if 48<=data [_efe ]&&data [_efe ]<=57{goto _ac ;};goto _ded ;_beb :_gcg :_gbf =0;goto _ffc ;_ggcb :_gbf =1;goto _ffc ;_gda :_gbf =2;goto _ffc ;_abbf :_gbf =3;goto _ffc ;_cab :_gbf =4;goto _ffc ;_cdfa :_gbf =5;goto _ffc ;_aaf :_gbf =6;goto _ffc ;_bfba :_gbf =7;goto _ffc ;_ffc :{};if _efe ==_ffde {switch _gbf {case 1:goto _ced ;case 2:goto _ced ;case 3:goto _gegg ;case 4:goto _ced ;case 5:goto _dade ;case 6:goto _ced ;case 7:goto _fgc ;};};};if _gbf ==_efd {return false ;};return ;};func _bd (_cf []byte )[]byte {for _cc :=0;_cc < len (_cf )/2;_cc ++{_ebf :=len (_cf )-1-_cc ;_cf [_cc ],_cf [_ebf ]=_cf [_ebf ],_cf [_cc ];};return _cf ;};func _ebdb (_edd _c .Time ,_dcf float64 ,_cdbe string )[]byte {_ccg :=[]byte {};_aece :=0;for _bcb :=0;_bcb < len (_cdbe );_bcb ++{var _degb string ;if _cdbe [_bcb ]==':'{_degb =string (_cdbe [_aece :_bcb ]);_aece =_bcb +1;}else if _bcb ==len (_cdbe )-1{_degb =string (_cdbe [_aece :_bcb +1]);}else {continue ;};switch _degb {case "\u0064":_ccg =_edd .AppendFormat (_ccg ,"\u0032");case "\u0068":_ccg =_edd .AppendFormat (_ccg ,"\u0033");case "\u0068\u0068":_ccg =_edd .AppendFormat (_ccg ,"\u0031\u0035");case "\u006d":_ccg =_edd .AppendFormat (_ccg ,"\u0034");case "\u006d\u006d":_ccg =_edd .AppendFormat (_ccg ,"\u0030\u0034");case "\u0073":_ccg =_edd .Round (_c .Second ).AppendFormat (_ccg ,"\u0035");case "\u0073\u002e\u0030":_ccg =_edd .Round (_c .Second /10).AppendFormat (_ccg ,"\u0035\u002e\u0030");case "\u0073\u002e\u0030\u0030":_ccg =_edd .Round (_c .Second /100).AppendFormat (_ccg ,"\u0035\u002e\u0030\u0030");case "\u0073\u002e\u00300\u0030":_ccg =_edd .Round (_c .Second /1000).AppendFormat (_ccg ,"\u0035\u002e\u00300\u0030");case "\u0073\u0073":_ccg =_edd .Round (_c .Second ).AppendFormat (_ccg ,"\u0030\u0035");case "\u0073\u0073\u002e\u0030":_ccg =_edd .Round (_c .Second /10).AppendFormat (_ccg ,"\u0030\u0035\u002e\u0030");case "\u0073\u0073\u002e0\u0030":_ccg =_edd .Round (_c .Second /100).AppendFormat (_ccg ,"\u0030\u0035\u002e0\u0030");case "\u0073\u0073\u002e\u0030\u0030\u0030":_ccg =_edd .Round (_c .Second /1000).AppendFormat (_ccg ,"\u0030\u0035\u002e\u0030\u0030\u0030");case "\u0041\u004d\u002fP\u004d":_ccg =_edd .AppendFormat (_ccg ,"\u0050\u004d");case "\u005b\u0068\u005d":_ccg =_ff .AppendInt (_ccg ,int64 (_dcf *24),10);case "\u005b\u006d\u005d":_ccg =_ff .AppendInt (_ccg ,int64 (_dcf *24*60),10);case "\u005b\u0073\u005d":_ccg =_ff .AppendInt (_ccg ,int64 (_dcf *24*60*60),10);case "":default:_cd .Log ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0069\u006d\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_degb );};if _cdbe [_bcb ]==':'{_ccg =append (_ccg ,':');};};return _ccg ;};const _fbc int =-1;